name: Poll Telegram for Commands

on:
  schedule:
    - cron: '* * * * *'
  workflow_dispatch:

jobs:
  poll:
    runs-on: ubuntu-latest
    env:
      TELEGRAM_OFFSET: ${{ vars.TELEGRAM_OFFSET || '0' }}
    steps:
      - name: Load Offset
        id: load
        run: |
          OFFSET="${{ env.TELEGRAM_OFFSET }}"
          echo "Current offset: $OFFSET"
          echo "offset=$OFFSET" >> $GITHUB_OUTPUT

      - name: Get Updates
        id: updates
        env:
          TG_BOT_TOKEN: ${{ secrets.TG_BOT_TOKEN }}
        run: |
          OFFSET=${{ steps.load.outputs.offset }}
          echo "Polling from offset: $OFFSET"
          UPDATES=$(curl -s "https://api.telegram.org/bot$TG_BOT_TOKEN/getUpdates?offset=$OFFSET&limit=20")
          echo "updates<<EOF" >> $GITHUB_OUTPUT
          echo "$UPDATES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          MAX_ID=$(echo "$UPDATES" | jq -r '.result[].update_id' | sort -nr | head -1)
          if [ "$MAX_ID" != "null" ] && [ -n "$MAX_ID" ]; then
            NEW_OFFSET=$((MAX_ID + 1))
            echo "New offset: $NEW_OFFSET"
            echo "TELEGRAM_OFFSET=$NEW_OFFSET" >> $GITHUB_ENV
          else
            echo "No new updates"
          fi

      - name: Update Offset in Repository Variables
        if: env.TELEGRAM_OFFSET != steps.load.outputs.offset
        uses: actions/github-script@v7
        with:
          script: |
            const newOffset = process.env.NEW_OFFSET;
            await github.rest.actions.createOrUpdateRepoSecret({
              owner: context.repo.owner,
              repo: context.repo.repo,
              secret_name: 'TELEGRAM_OFFSET',
              key_id: (await github.rest.actions.listRepoSecrets({owner: context.repo.owner, repo: context.repo.repo})).data.secrets.find(s => s.name === 'TELEGRAM_OFFSET')?.key_id,
              encrypted_value: btoa(newOffset)
            }).catch(() => {
              // If secret doesn't exist, create it
              return github.rest.actions.createRepoSecret({
                owner: context.repo.owner,
                repo: context.repo.repo,
                secret_name: 'TELEGRAM_OFFSET',
                key_id: (await github.rest.actions.getPublicKey({owner: context.repo.owner, repo: context.repo.repo})).data.key_id,
                encrypted_value: btoa(newOffset)
              });
            });

      - name: Respond to /start
        if: contains(steps.updates.outputs.updates, '/start')
        env:
          TG_BOT_TOKEN: ${{ secrets.TG_BOT_TOKEN }}
          TG_CHAT_ID: ${{ secrets.TG_CHAT_ID }}
        run: |
          curl -s -X POST "https://api.telegram.org/bot$TG_BOT_TOKEN/sendMessage" \
            -d chat_id="$TG_CHAT_ID" \
            -d text="Bot 已就绪！发 /retry 触发任务" \
            -d parse_mode="Markdown"

      - name: Trigger on /retry
        if: contains(steps.updates.outputs.updates, '/retry')
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
          TG_BOT_TOKEN: ${{ secrets.TG_BOT_TOKEN }}
          TG_CHAT_ID: ${{ secrets.TG_CHAT_ID }}
        run: |
          echo "检测到 /retry，触发主任务"
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
            -H "Authorization: Bearer $GH_PAT" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/${{ github.repository }}/actions/workflows/wispbyte-auto-login.yml/dispatches \
            -d '{"ref":"main"}')
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          if [ "$HTTP_CODE" = "204" ]; then
            curl -s -X POST "https://api.telegram.org/bot$TG_BOT_TOKEN/sendMessage" \
              -d chat_id="$TG_CHAT_ID" \
              -d text="Workflow 已触发重试！"
          else
            curl -s -X POST "https://api.telegram.org/bot$TG_BOT_TOKEN/sendMessage" \
              -d chat_id="$TG_CHAT_ID" \
              -d text="触发失败：HTTP $HTTP_CODE\n请检查 GH_PAT 权限"
          fi
